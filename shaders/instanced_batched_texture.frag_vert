#version 460 core

#define MAX_LIGHTS 32
#define MAX_BATCH 8
#define MAP_BIT_DIFFUSE 1
#define MAP_BIT_AMBIENT 2
#define MAP_BIT_SPCULAR 4
#define MAP_BIT_NORMAL 8

struct Light{
    vec4 pos_and_range;
    vec4 color_and_radius;
};

layout(std140) uniform Environment {
    mat4 projection;
    mat4 view;
    vec4 view_pos;
    vec4 base_illumination;

    float light_linear_attentuation;
    float light_quadratic_attentuation;
    float gamma;
    int   lights_count;

    Light lights[MAX_LIGHTS];
} env;

struct Params_Data {
    vec4 diffuse_color;
    vec4 ambient_color;
    vec4 specular_color;
    float specular_exponent;    
    float metallic;             

    int map_flags;
};

layout(std140) uniform Params {
    Params_Data params[MAX_BATCH];  
};

uniform sampler2D u_maps_diffuse[MAX_BATCH];
uniform sampler2D u_maps_specular[MAX_BATCH];
uniform sampler2D u_maps_normal[MAX_BATCH];
uniform sampler2DArray u_map_array_test;

#ifdef FRAG
    out vec4 o_color;
    
    in VS_OUT { 
        vec3 frag_pos;
        vec2 uv;
        vec3 norm;
        flat int batch_index;
    } _in;

    void main()
    {
        int bi = _in.batch_index;
        //Most common value for specular intensity
        const float base_specular_exponent = 10;

        Params_Data param = params[bi];

        vec3  diffuse_color = param.diffuse_color.xyz;
        vec3  specular_color = param.specular_color.xyz;
        vec3  ambient_color = param.ambient_color.xyz;
        float metallic = sqrt(param.metallic); //to better follow the intuitive linearity of this parameter
        float specular_exponent = param.specular_exponent;
        int   map_flags = param.map_flags;

        if((map_flags & MAP_BIT_DIFFUSE) != 0)
        {
            //diffuse_color = texture(u_maps_diffuse[bi], _in.uv).xyz;
            diffuse_color = texture(u_map_array_test, vec3(_in.uv.xy, 0)).xyz;
        }
            
        if((map_flags & MAP_BIT_SPCULAR) != 0)
            specular_color = texture(u_maps_specular[bi], _in.uv).xyz;

        //so that when extra expontiated extra shiny!
        float specular_intensity = log(specular_exponent / base_specular_exponent + 1);
        specular_intensity = 1;

        vec3 diffuse_illumination = diffuse_color * env.base_illumination.xyz;
        vec3 specular_illumination = vec3(0, 0, 0);
        
        vec3 normal = normalize(_in.norm);
        vec3 view_dir = normalize(env.view_pos.xyz - _in.frag_pos);

        for(int i = 0; i < env.lights_count; i++)
        {
            float light_range = env.lights[i].pos_and_range.w;
            vec3 light_pos = env.lights[i].pos_and_range.xyz;
            vec3 light_color = env.lights[i].color_and_radius.xyz;

            float light_dist = length(light_pos - _in.frag_pos);
            float attentuation = 1;
            attentuation = 1 / (1 + light_dist*light_dist*env.light_quadratic_attentuation + light_dist*env.light_linear_attentuation);

            //If too far skip or too irrelavant skip
            if(light_dist <= light_range && attentuation > 0.0001)
            {
                vec3 light_dir = normalize(light_pos - _in.frag_pos);
                vec3 reflect_dir = reflect(-light_dir, normal);
                vec3 halfway_dir = normalize(light_dir + view_dir);  

                float diffuse_mult = max(dot(light_dir, normal), 0.0);
                float specular_mult_uncapped = pow(max(dot(normal, halfway_dir), 0), specular_exponent);
        
                // correct the specular so that there is no specular where diffuse is zero.
                // we do custom falloff similar to the curve of x^(1/4) because it looks bad when we simply
                // cut it off when diffuse_mult is zero
                float epsilon = 0.05;
                float sharpness = 2;
                float specular_correction = 1 - pow(abs(min(diffuse_mult - epsilon, 0))/epsilon, sharpness);
                float specular_mult = specular_mult_uncapped * specular_correction;

                diffuse_illumination += light_color * diffuse_mult * attentuation;
                specular_illumination += light_color * specular_mult * attentuation;
            }
        }

        vec3 diffuse_sum = diffuse_color * diffuse_illumination * (1 - metallic);

        vec3 reflection_color = mix(specular_color, diffuse_color, metallic);
        vec3 specular_sum = reflection_color * specular_illumination * specular_intensity;
        
        vec3 ambient_sum = ambient_color;

        vec3 result = ambient_sum + diffuse_sum + specular_sum;
        o_color = vec4(result, 1.0);
        //o_color = vec4(specular_sum*0.1f, 1.0);
    }
#endif 

#ifdef VERT
    layout (location = 0) in vec3 a_pos;
    layout (location = 1) in vec2 a_uv;
    layout (location = 2) in vec3 a_norm;
    layout (location = 5) in mat4 a_model;
    
    out VS_OUT { 
        vec3 frag_pos;
        vec2 uv;
        vec3 norm;
        flat int batch_index;
    } _out;

    void main()
    {
        vec4 fragment_pos = a_model * vec4(a_pos, 1.0);
        vec4 world_pos = env.projection * env.view * a_model * vec4(a_pos, 1.0);
        
        _out.frag_pos = fragment_pos.xyz;
        _out.uv = a_uv;
        _out.norm = a_norm;
        _out.batch_index = gl_DrawID;

        gl_Position = world_pos;
    } 
#endif